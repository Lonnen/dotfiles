{"mode":"editor","version":"0.73.0","windowDimensions":{"x":0,"y":22,"width":958,"height":1178},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/01-fizzbuzz/tests.bats":"source.shell"}},"project":{"path":"/Users/lonnen/repos/webeng-2014-puzzles","buffers":[{"text":"#!/bin/bash\nset -eo pipefail\n\nexport TESTS=\"$1\"\nexport SOLUTIONS=\"$2\"\n\nfunction exec_tests() {\n    SOLUTION=`pwd`/$1\n    PUZZLE=$(basename $SOLUTION)\n    TESTFILE=$TESTS/$PUZZLE/tests.sh\n    [ ! -f $TESTFILE ] && {\n        echo \"skipping $PUZZLE - no matching test suite\"\n        return\n    }\n    pushd $TESTS/$PUZZLE > /dev/null\n    ./tests.sh $SOLUTION\n    popd  > /dev/null\n}\n\nfor FILE in $(find $SOLUTIONS -maxdepth 1 -type f); do\n    exec_tests $FILE\ndone\n","markers":{"markers":{"1":{"id":1,"range":[[0,0],[0,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":1159,"preserveFolds":true,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/lonnen/repos/webeng-2014-puzzles/runtests","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"eb7ac36ad530632a117e63eeddf110f648839f7a","deserializer":"TextBuffer"},{"text":"#!/bin/bash\n# assert.sh 1.0 - bash unit testing framework\n# Copyright (C) 2009, 2010, 2011, 2012 Robert Lehmann\n#\n# http://github.com/lehmannro/assert.sh\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser General Public License as published\n# by the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n# GNU Lesser General Public License for more details.\n#\n# You should have received a copy of the GNU Lesser General Public License\n# along with this program. If not, see <http://www.gnu.org/licenses/>.\n\nexport DISCOVERONLY=${DISCOVERONLY:-}\nexport DEBUG=${DEBUG:-}\nexport STOP=${STOP:-}\nexport INVARIANT=${INVARIANT:-}\n\nargs=\"$(getopt -n \"$0\" -l verbose,help,stop,discover,invariant vhxdi $*)\" \\\n|| exit -1\nfor arg in $args; do\ncase \"$arg\" in\n        -h)\n            echo \"$0 [-vxid] [--verbose] [--stop] [--invariant] [--discover]\"\n            echo \"`sed 's/./ /g' <<< \"$0\"` [-h] [--help]\"\n            exit 0;;\n        --help)\n            cat <<EOF\nUsage: $0 [options]\nLanguage-agnostic unit tests for subprocesses.\n\nOptions:\n-v, --verbose generate output for every individual test case\n-x, --stop stop running tests after the first failure\n-i, --invariant do not measure timings to remain invariant between runs\n-d, --discover collect test suites only, do not run any tests\n-h show brief usage information and exit\n--help show this help message and exit\nEOF\n            exit 0;;\n        -v|--verbose)\n            DEBUG=1;;\n        -x|--stop)\n            STOP=1;;\n        -i|--invariant)\n            INVARIANT=1;;\n        -d|--discover)\n            DISCOVERONLY=1;;\n    esac\ndone\n\nprintf -v _indent \"\\n\\t\" # local format helper\n\n_assert_reset() {\n    tests_ran=0\n    tests_failed=0\n    tests_errors=()\n    tests_starttime=\"$(date +%s)\" # seconds_since_epoch.nanoseconds\n}\n\nassert_end() {\n    # assert_end [suite ..]\n    tests_endtime=\"$(date +%s)\"\n    tests=\"$tests_ran ${*:+$* }tests\"\n    [[ -n \"$DISCOVERONLY\" ]] && echo \"collected $tests.\" && _assert_reset && return\n    [[ -n \"$DEBUG\" ]] && echo\n    [[ -z \"$INVARIANT\" ]] && report_time=\" in $(expr $tests_endtime - $tests_starttime)s\" || report_time=\n\n    if [[ \"$tests_failed\" -eq 0 ]]; then\necho \"all $tests passed$report_time.\"\n    else\nfor error in \"${tests_errors[@]}\"; do echo \"$error\"; done\necho \"$tests_failed of $tests failed$report_time.\"\n    fi\ntests_failed_previous=$tests_failed\n    _assert_reset\n    return $tests_failed_previous\n}\n\nassert() {\n    # assert <command> <expected stdout> [stdin]\n    (( tests_ran++ ))\n    [[ -n \"$DISCOVERONLY\" ]] && return\n    # printf required for formatting\n    printf -v expected \"x${2:-}\" # x required to overwrite older results\n    result=\"$(eval 2>/dev/null $1 <<< ${3:-})\"\n    # Note: $expected is already decorated\n    if [[ \"x$result\" == \"$expected\" ]]; then\n        [[ -n \"$DEBUG\" ]] && echo -n .\n        return\nfi\n    [[ -n \"$DEBUG\" ]] && echo -n X\n    result=\"$(sed -e :a -e '$!N;s/\\n/\\\\n/;ta' <<< \"$result\")\"\n    [[ -z \"$result\" ]] && result=\"nothing\" || result=\"\\\"$result\\\"\"\n    [[ -z \"$2\" ]] && expected=\"nothing\" || expected=\"\\\"$2\\\"\"\n    failure=\"expected result:${_indent}$result\"\n    [[ -n \"$TITLE\" ]] || export TITLE=\"\"\n    report=\"test #$tests_ran \\\"$TITLE\\\" failed.\"\n    tests_errors[$tests_failed]=\"$report\"\n    (( tests_failed++ ))\n    if [[ -n \"$STOP\" ]]; then\n        [[ -n \"$DEBUG\" ]] && echo\necho \"$report\"\n        exit 1\n    fi\n}\n\nassert_raises() {\n    # assert_raises <command> <expected code> [stdin]\n    (( tests_ran++ ))\n    [[ -n \"$DISCOVERONLY\" ]] && return\n    (eval $1 <<< ${3:-}) > /dev/null 2>&1\n    status=$?\n    expected=${2:-0}\n    if [[ \"$status\" -eq \"$expected\" ]]; then\n        [[ -n \"$DEBUG\" ]] && echo -n .\n        return\nfi\n    [[ -n \"$DEBUG\" ]] && echo -n X\n    failure=\"program terminated with code $status instead of $expected\"\n    report=\"test #$tests_ran \\\"$1${3:+ <<< $3}\\\" failed:${_indent}$failure\"\n    tests_errors[$tests_failed]=\"$report\"\n    (( tests_failed++ ))\n    if [[ -n \"$STOP\" ]]; then\n        [[ -n \"$DEBUG\" ]] && echo\necho \"$report\"\n        exit 1\n    fi\n}\n\n_assert_reset\n","markers":{"markers":{"1":{"id":1,"range":[[69,0],[69,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":1163,"autoscroll":true,"goalBufferRange":null,"preserveFolds":true},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/assert.sh","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"fe4a03b5fdb49382af50d13c85ccf11c75bcde25","deserializer":"TextBuffer"},{"text":"# Gattaca\n\nBorrowed from an old interview puzzle.\n\nYou have a DNA string that you wish to analyze. Of particular interest are which intervals of the string represent individual genes. You have a number of \"gene predictions\", each of which assigns a score to an interval within the DNA string, and you want to find the subset of predictions such that the total score is maximized while avoiding overlaps. A gene prediction is a triple of the form (start, stop, score). start is the zero-based index of the first character in the DNA string contained in the gene. stop is the index of the last character contained in the gene. score is the score for the gene.\n\n# Input Specification\n\nYour program will be passed the name of an input file on the command line. The contents of that file are as follows.\n\nThe first line of the input contains only n, the length of the DNA string you will be given.\n\nThe next ceiling(n / 80) lines each contain string of length 80 (or n % 80 for the last line) containing only the characters 'A', 'C', 'G', and 'T'. Concatenate these lines to get the entire DNA strand.\n\nThe next line contains only g, the number of gene predictions you will be given.\n\nThe next g lines each contain a whitespace-delimited triple of integers of the form\n\n<start> <stop> <score>\n\nrepresenting a single gene prediction. No gene predictions will exceed the bounds of the DNA string or be malformed (start is non-negative and no more than stop, stop never exceeds n - 1).\n\nExample Input:\n\n  100\n  GAACTATCGCCCGTGCGCATCGCCCGTCCGACCGGCCGTAAGTCTATCTCCCGAGCGGGCGCCCGATCTCAAGTGCACCT\n  CACGGCCTCACGACCGTGAG\n  8\n  43  70  27\n  3   18  24\n  65  99  45\n  20  39  26\n  45  74  26\n  10  28  20\n  78  97  23\n  0   9   22\n\n# Output Specification\n\nPrint to standard out the score of the best possible subset of the gene predictions you are given such that no single index in the DNA string is contained in more than one gene prediction, followed by a newline. The total score is simply the sum of the scores of the gene predictions included in your final result.\n\nWhen constructing your output, you may only consider genes exactly as they are described in the input. If you find the contents of a gene replicated elsewhere in the DNA string, you are not allowed to treat the second copy as a viable gene. Your solution must be fast and efficient to be considered correct by the robot.\n\nExample Output:\n\n100\n","markers":{"markers":{"1":{"id":1,"range":[[5,0],[5,0]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":1198,"goalBufferRange":null},"deserializer":"Marker"},"4":{"id":4,"range":[[0,2],[0,9]],"tailed":true,"reversed":false,"valid":true,"invalidate":"inside","persistent":true,"properties":{"replicate":false},"deserializer":"Marker"},"5":{"id":5,"range":[[26,2],[26,22]],"tailed":true,"reversed":false,"valid":true,"invalidate":"inside","persistent":true,"properties":{"replicate":false},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/02-GATTACA/README.md","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"bda05f5b0f6c43f964ca42edf8fb5f3017d5f398","deserializer":"TextBuffer"},{"text":"#!/usr/bin/env python\n\nimport sys\nimport math\nfrom collections import namedtuple\n\nNode = namedtuple('Node', ['pred', 'children', 'score'])\n\ndef intersects(a, b):\n    return min(a[1], b[1]) > max(a[0], b[0])\n\ndef insert(node, p):\n    if intersects(p, node.pred):\n        return False\n\n    inserted = False\n    c_max_score = 0\n\n    for c in node.children:\n        inserted |= insert(c, p)\n        c_max_score = max(c_max_score, c.score[0])\n\n    if not inserted:\n        node.children.append(Node(p, [], [p[2]]))\n        c_max_score = max(c_max_score, p[2])\n\n    node.score[0] = node.pred[2] + c_max_score\n\n    return True\n\nwith open(sys.argv[1]) as f:\n    n = int(f.readline())\n    lines = int(math.ceil(n/80.0))\n    s = ''.join(f.readline().strip() for _ in range(0, lines))\n    g = int(f.readline())\n    predictions = [ tuple([int(x) for x in f.readline().split()]) for _ in range(0, g)]\n\npredictions.sort(key=lambda p: p[0])\n\nroot = Node((-1, -2, 0), [], [0,])\n\nfor p in predictions:\n    insert(root, p)\n\nprint root.score[0]\n","markers":{"markers":{"1":{"id":1,"range":[[35,74],[35,74]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":1200,"goalBufferRange":null},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[],"redoStack":[],"deserializer":"History"},"filePath":"/Users/lonnen/repos/webeng-2014-puzzles/reference/02-GATTACA","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"dd6ad6e260f86e1a12cbafcc29a9b0bc9b789f08","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"items":[{"id":1159,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":1160,"softWrap":true,"editorWidthInChars":103,"tokenizedBuffer":{"bufferPath":"/Users/lonnen/repos/webeng-2014-puzzles/runtests","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":1163,"softTabs":true,"scrollTop":990,"scrollLeft":0,"displayBuffer":{"id":1164,"softWrap":true,"editorWidthInChars":102,"tokenizedBuffer":{"bufferPath":"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/assert.sh","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":1198,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":1199,"softWrap":true,"editorWidthInChars":103,"tokenizedBuffer":{"bufferPath":"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/02-GATTACA/README.md","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"},{"id":1200,"softTabs":true,"scrollTop":0,"scrollLeft":0,"displayBuffer":{"id":1201,"softWrap":true,"editorWidthInChars":103,"tokenizedBuffer":{"bufferPath":"/Users/lonnen/repos/webeng-2014-puzzles/reference/02-GATTACA","tabLength":2,"deserializer":"TokenizedBuffer"},"deserializer":"DisplayBuffer"},"deserializer":"Editor"}],"activeItemUri":"/Users/lonnen/repos/webeng-2014-puzzles/reference/02-GATTACA","focused":true,"active":true,"deserializer":"Pane"},"deserializer":"PaneContainer"},"fullScreen":false,"deserializer":"Workspace"},"packageStates":{"command-logger":{"eventLog":{"settings-view:open":{"count":1,"name":"settings-view:open","lastRun":1395425807806},"core:backspace":{"count":1202,"name":"core:backspace","lastRun":1395883612198},"core:close":{"count":123,"name":"core:close","lastRun":1395883084092},"tree-view:add-file":{"count":17,"name":"tree-view:add-file","lastRun":1395880116332},"editor:move-to-first-character-of-line":{"count":49,"name":"editor:move-to-first-character-of-line","lastRun":1395883828172},"editor:move-to-end-of-screen-line":{"count":70,"name":"editor:move-to-end-of-screen-line","lastRun":1395883827708},"core:paste":{"count":68,"name":"core:paste","lastRun":1395880433400},"core:move-down":{"count":393,"name":"core:move-down","lastRun":1395942501614},"core:select-up":{"count":22,"name":"core:select-up","lastRun":1395878406875},"tree-view:remove":{"count":20,"name":"tree-view:remove","lastRun":1395880771584},"core:save":{"count":334,"name":"core:save","lastRun":1395883614359},"core:move-left":{"count":523,"name":"core:move-left","lastRun":1395883593387},"editor:newline":{"count":171,"name":"editor:newline","lastRun":1395883594147},"core:cut":{"count":13,"name":"core:cut","lastRun":1395606840052},"core:move-up":{"count":334,"name":"core:move-up","lastRun":1395883589275},"core:undo":{"count":271,"name":"core:undo","lastRun":1395883603792},"core:copy":{"count":35,"name":"core:copy","lastRun":1395883514773},"find-and-replace:show":{"count":30,"name":"find-and-replace:show","lastRun":1395883420302},"editor:consolidate-selections":{"count":8,"name":"editor:consolidate-selections","lastRun":1395779061703},"core:redo":{"count":19,"name":"core:redo","lastRun":1395819851159},"snippets:next-tab-stop":{"count":31,"name":"snippets:next-tab-stop","lastRun":1395883596020},"snippets:expand":{"count":31,"name":"snippets:expand","lastRun":1395883596021},"editor:indent":{"count":31,"name":"editor:indent","lastRun":1395883596022},"core:select-down":{"count":55,"name":"core:select-down","lastRun":1395883580123},"core:select-left":{"count":7,"name":"core:select-left","lastRun":1395883586507},"application:new-file":{"count":4,"name":"application:new-file","lastRun":1395869009357},"editor:indent-selected-rows":{"count":26,"name":"editor:indent-selected-rows","lastRun":1395868442642},"core:move-to-top":{"count":8,"name":"core:move-to-top","lastRun":1395880123045},"core:delete":{"count":247,"name":"core:delete","lastRun":1395883613872},"core:move-to-bottom":{"count":3,"name":"core:move-to-bottom","lastRun":1395606447073},"autocomplete:toggle":{"count":2,"name":"autocomplete:toggle","lastRun":1395561752861},"tree-view:move":{"count":6,"name":"tree-view:move","lastRun":1395790670985},"core:move-right":{"count":294,"name":"core:move-right","lastRun":1395942501377},"fuzzy-finder:toggle-file-finder":{"count":1,"name":"fuzzy-finder:toggle-file-finder","lastRun":1395561823441},"grammar-selector:show":{"count":1,"name":"grammar-selector:show","lastRun":1395561827219},"editor:select-to-end-of-line":{"count":4,"name":"editor:select-to-end-of-line","lastRun":1395883581043},"pane:show-previous-item":{"count":50,"name":"pane:show-previous-item","lastRun":1395875061457},"pane:show-next-item":{"count":55,"name":"pane:show-next-item","lastRun":1395878273914},"tree-view:copy":{"count":5,"name":"tree-view:copy","lastRun":1395879594849},"tree-view:paste":{"count":12,"name":"tree-view:paste","lastRun":1395879895767},"tree-view:open-selected-entry":{"count":1,"name":"tree-view:open-selected-entry","lastRun":1395564652284},"editor:select-to-first-character-of-line":{"count":11,"name":"editor:select-to-first-character-of-line","lastRun":1395880330782},"tree-view:copy-full-path":{"count":2,"name":"tree-view:copy-full-path","lastRun":1395602014894},"core:select-all":{"count":17,"name":"core:select-all","lastRun":1395880433191},"core:select-right":{"count":15,"name":"core:select-right","lastRun":1395609076656},"editor:newline-above":{"count":2,"name":"editor:newline-above","lastRun":1395632256543},"tree-view:add-folder":{"count":5,"name":"tree-view:add-folder","lastRun":1395879490547},"editor:outdent-selected-rows":{"count":2,"name":"editor:outdent-selected-rows","lastRun":1395790582250},"editor:backspace-to-beginning-of-line":{"count":1,"name":"editor:backspace-to-beginning-of-line","lastRun":1395817517786},"tree-view:expand-directory":{"count":4,"name":"tree-view:expand-directory","lastRun":1395879515914},"tree-view:duplicate":{"count":1,"name":"tree-view:duplicate","lastRun":1395868337824},"tree-view:show-in-file-manager":{"count":1,"name":"tree-view:show-in-file-manager","lastRun":1395879923688}}},"fuzzy-finder":{"/Users/lonnen/repos/webeng-2014-puzzles/runtests":1395883090799,"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/assert.sh":1395942585793,"/Users/lonnen/repos/webeng-2014-puzzles/puzzles/02-GATTACA/README.md":1395942586898,"/Users/lonnen/repos/webeng-2014-puzzles/reference/02-GATTACA":1395942588675},"keybinding-resolver":{"attached":false},"metrics":{"sessionLength":95806346},"tree-view":{"directoryExpansionStates":{"puzzles":{"02-GATTACA":{}},"reference":{}},"selectedPath":"/Users/lonnen/repos/webeng-2014-puzzles/reference/02-GATTACA","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200},"find-and-replace":{"viewState":{"findHistory":["reference","submission","$TESTS","filre","filename","puzzle","FILENAME","expected","echo","player","expected","bc","bv","bc"],"replaceHistory":["SOLUTIONS","puzzle","PUZZLE","SOLUTION"],"modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false}}}}}