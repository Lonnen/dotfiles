{"mode":"editor","version":1,"windowDimensions":{"x":958,"y":22,"width":958,"height":1178,"maximized":false},"syntax":{"deserializer":"Syntax","grammarOverridesByPath":{}},"project":{"paths":["/Users/lonnen/repos/socorro"],"buffers":[{"text":"# This Source Code Form is subject to the terms of the Mozilla Public\n# License, v. 2.0. If a copy of the MPL was not distributed with this\n# file, You can obtain one at http://mozilla.org/MPL/2.0/.\n\nimport re\n\nfrom itertools import islice\n\nfrom configman import Namespace, RequiredConfig\nfrom configman.converters import class_converter\n\nfrom socorro.lib.transform_rules import Rule\nfrom socorro.external.postgresql.dbapi2_util import execute_query_fetchall\n\n\n#==============================================================================\nclass SignatureTool(RequiredConfig):\n    \"\"\"this is the base class for signature generation objects.  It defines the\n    basic interface and provides truncation and quoting service.  Any derived\n    classes should implement the '_do_generate' function.  If different\n    truncation or quoting techniques are desired, then derived classes may\n    override the 'generate' function.\"\"\"\n    required_config = Namespace()\n\n    #--------------------------------------------------------------------------\n    def __init__(self, config, quit_check_callback=None):\n        self.config = config\n        self.max_len = config.setdefault('signature_max_len', 255)\n        self.escape_single_quote = \\\n            config.setdefault('signature_escape_single_quote', True)\n        self.quit_check_callback = quit_check_callback\n\n    #--------------------------------------------------------------------------\n    def generate(\n        self,\n        source_list,\n        hang_type=0,\n        crashed_thread=None,\n        delimiter=' | '\n    ):\n        signature, signature_notes = self._do_generate(\n            source_list,\n            hang_type,\n            crashed_thread,\n            delimiter\n        )\n        if self.escape_single_quote:\n            signature = signature.replace(\"'\", \"''\")\n        if len(signature) > self.max_len:\n            signature = \"%s...\" % signature[:self.max_len - 3]\n            signature_notes.append('SignatureTool: signature truncated due to '\n                                   'length')\n        return signature, signature_notes\n\n    #--------------------------------------------------------------------------\n    def _do_generate(\n        self,\n        source_list,\n        hang_type,\n        crashed_thread,\n        delimiter\n    ):\n        raise NotImplementedError\n\n\n#==============================================================================\nclass CSignatureToolBase(SignatureTool):\n    \"\"\"This is the base class for signature generation tools that work on\n    breakpad C/C++ stacks.  It provides a method to normalize signatures\n    and then defines its own '_do_generate' method.\"\"\"\n\n    hang_prefixes = {\n        -1: \"hang\",\n        1: \"chromehang\"\n    }\n\n    #--------------------------------------------------------------------------\n    def __init__(self, config, quit_check_callback=None):\n        super(CSignatureToolBase, self).__init__(config, quit_check_callback)\n        self.irrelevant_signature_re = None\n        self.prefix_signature_re = None\n        self.signatures_with_line_numbers_re = None\n        self.signature_sentinels = []\n\n        self.fixup_space = re.compile(r' (?=[\\*&,])')\n        self.fixup_comma = re.compile(r',(?! )')\n        self.fixup_integer = re.compile(r'(<|, )(\\d+)([uUlL]?)([^\\w])')\n\n    #--------------------------------------------------------------------------\n    def normalize_signature(\n        self,\n        module=None,\n        function=None,\n        file=None,\n        line=None,\n        module_offset=None,\n        offset=None,\n        function_offset=None,\n        normalized=None,\n        **kwargs  # eat any extra kwargs passed in\n    ):\n        \"\"\" returns a structured conglomeration of the input parameters to\n        serve as a signature.  The parameter names of this function reflect the\n        exact names of the fields from the jsonMDSW frame output.  This allows\n        this function to be invoked by passing a frame as **a_frame. Sometimes,\n        a frame may already have a normalized version cached.  If that exsists,\n        return it instead.\n        \"\"\"\n        if normalized is not None:\n            return normalized\n        if function:\n            if self.signatures_with_line_numbers_re.match(function):\n                function = \"%s:%s\" % (function, line)\n            # Remove spaces before all stars, ampersands, and commas\n            function = self.fixup_space.sub('', function)\n            # Ensure a space after commas\n            function = self.fixup_comma.sub(', ', function)\n            # normalize template signatures with manifest const integers to\n            #'int': Bug 481445\n            function = self.fixup_integer.sub(r'\\1int\\4', function)\n            return function\n        #if source is not None and source_line is not None:\n        if file and line:\n            filename = file.rstrip('/\\\\')\n            if '\\\\' in filename:\n                file = filename.rsplit('\\\\')[-1]\n            else:\n                file = filename.rsplit('/')[-1]\n            return '%s#%s' % (file, line)\n        if not module and not module_offset and offset:\n            return \"@%s\" % offset\n        if not module:\n            module = ''  # might have been None\n        return '%s@%s' % (module, module_offset)\n\n    #--------------------------------------------------------------------------\n    def _do_generate(self,\n                     source_list,\n                     hang_type,\n                     crashed_thread,\n                     delimiter=' | '):\n        \"\"\"\n        each element of signatureList names a frame in the crash stack; and is:\n          - a prefix of a relevant frame: Append this element to the signature\n          - a relevant frame: Append this element and stop looking\n          - irrelevant: Append this element only after seeing a prefix frame\n        The signature is a ' | ' separated string of frame names\n        \"\"\"\n        signature_notes = []\n        # shorten source_list to the first signatureSentinel\n        sentinel_locations = []\n        for a_sentinel in self.signature_sentinels:\n            if type(a_sentinel) == tuple:\n                a_sentinel, condition_fn = a_sentinel\n                if not condition_fn(source_list):\n                    continue\n            try:\n                sentinel_locations.append(source_list.index(a_sentinel))\n            except ValueError:\n                pass\n        if sentinel_locations:\n            source_list = source_list[min(sentinel_locations):]\n        new_signature_list = []\n        for a_signature in source_list:\n            if self.irrelevant_signature_re.match(a_signature):\n                continue\n            new_signature_list.append(a_signature)\n            if not self.prefix_signature_re.match(a_signature):\n                break\n        if hang_type:\n            new_signature_list.insert(0, self.hang_prefixes[hang_type])\n        signature = delimiter.join(new_signature_list)\n\n        if signature == '' or signature is None:\n            if crashed_thread is None:\n                signature_notes.append(\"CSignatureTool: No signature could be \"\n                                       \"created because we do not know which \"\n                                       \"thread crashed\")\n                signature = \"EMPTY: no crashing thread identified\"\n            else:\n                signature_notes.append(\"CSignatureTool: No proper signature \"\n                                       \"could be created because no good data \"\n                                       \"for the crashing thread (%s) was found\"\n                                       % crashed_thread)\n                try:\n                    signature = source_list[0]\n                except IndexError:\n                    signature = \"EMPTY: no frame data available\"\n\n        return signature, signature_notes\n\n\n#==============================================================================\nclass CSignatureTool(CSignatureToolBase):\n    \"\"\"This is a C/C++ signature generation class that gets its initialization\n    from configuration.\"\"\"\n\n    required_config = Namespace()\n    required_config.add_option(\n        'signature_sentinels',\n        doc='a list of frame signatures that should always be considered top '\n            'of the stack if present in the stack',\n        default=\"\"\"['_purecall',\n               ('mozilla::ipc::RPCChannel::Call(IPC::Message*, IPC::Message*)',\n                lambda x: 'CrashReporter::CreatePairedMinidumps(void*, '\n                  'unsigned long, nsAString_internal*, nsILocalFile**, '\n                  'nsILocalFile**)' in x\n               ),\n               'Java_org_mozilla_gecko_GeckoAppShell_reportJavaCrash',\n               'google_breakpad::ExceptionHandler::HandleInvalidParameter'\n                  '(wchar_t const*, wchar_t const*, wchar_t const*, unsigned '\n                  'int, unsigned int)'\n              ]\"\"\",\n        from_string_converter=eval\n    )\n    required_config.add_option(\n        'irrelevant_signature_re',\n        doc='a regular expression matching frame signatures that should be '\n            'ignored when generating an overall signature',\n        default=\"\"\"'|'.join([\n          '@0x[0-9a-fA-F]{2,}',\n          '@0x[1-9a-fA-F]',\n          '__aeabi_fcmpgt.*',\n          'ashmem',\n          'app_process@0x.*',\n          'core\\.odex@0x.*',\n          '_CxxThrowException',\n          'dalvik-heap',\n          'dalvik-jit-code-cache',\n          'dalvik-LinearAlloc',\n          'dalvik-mark-stack',\n          'data@app@org\\.mozilla\\.f.*-\\d\\.apk@classes\\.dex@0x.*',\n          'framework\\.odex@0x.*',\n          'google_breakpad::ExceptionHandler::HandleInvalidParameter.*',\n          'KiFastSystemCallRet',\n          'libandroid_runtime\\.so@0x.*',\n          'libbinder\\.so@0x.*',\n          'libc\\.so@.*',\n          'libc-2\\.5\\.so@.*',\n          'libEGL\\.so@.*',\n          'libdvm\\.so\\s*@\\s*0x.*',\n          'libgui\\.so@0x.*',\n          'libicudata.so@.*',\n          'libMali\\.so@0x.*',\n          'libutils\\.so@0x.*',\n          'libz\\.so@0x.*',\n          'linux-gate\\.so@0x.*',\n          'mnt@asec@org\\.mozilla\\.f.*-\\d@pkg\\.apk@classes\\.dex@0x.*',\n          'MOZ_Assert',\n          'MOZ_Crash',\n          'mozcrt19.dll@0x.*',\n          'mozilla::ipc::RPCChannel::Call\\(IPC::Message\\*, IPC::Message\\*\\)',\n          '_NSRaiseError',\n          '(Nt|Zw)WaitForSingleObject(Ex)?',\n          '(Nt|Zw)WaitForMultipleObjects(Ex)?',\n          'nvmap@0x.*',\n          'org\\.mozilla\\.f.*-\\d\\.apk@0x.*',\n          'RaiseException',\n          'RtlpAdjustHeapLookasideDepth',\n          'system@framework@.*\\.jar@classes\\.dex@0x.*',\n          '___TERMINATING_DUE_TO_UNCAUGHT_EXCEPTION___',\n          'WaitForSingleObjectExImplementation',\n          'WaitForMultipleObjectsExImplementation',\n          'RealMsgWaitFor.*'\n          '_ZdlPv',\n          'zero',\n          ])\"\"\",\n        from_string_converter=eval\n    )\n    required_config.add_option(\n        'prefix_signature_re',\n        doc=(\n            'a regular expression matching frame signatures that should '\n            'always be coupled with the following frame signature when '\n            'generating an overall signature'\n        ),\n        default=\"\"\"'|'.join([\n          '@0x0',\n          '.*CrashAtUnhandlableOOM',\n          'Abort',\n          '.*abort',\n          '.*alloc_impl',\n          '_alloca_probe.*',\n          '__android_log_assert',\n          'arena_.*',\n          'BaseGetNamedObjectDirectory',\n          '.*calloc',\n          'cert_.*',\n          'CERT_.*',\n          'CFRelease',\n          '_chkstk',\n          'CleanupPerAppKey',\n          'CrashInJS',\n          '__delayLoadHelper2',\n          'dlmalloc',\n          'dlmalloc_trim',\n          'dvm.*',\n          'EtwEventEnabled',\n          'extent_.*',\n          'fastcopy_I',\n          'fastzero_I',\n          '_files_getaddrinfo',\n          '.*free',\n          'free_impl',\n          'GCGraphBuilder::NoteXPCOMChild',\n          'getanswer',\n          'HandleInvalidParameter',\n          'HeapFree',\n          'huge_dalloc',\n          'ialloc',\n          'imalloc',\n          'init_library',\n          'invalid_parameter_noinfo',\n          'isalloc',\n          'jemalloc_crash',\n          'je_.*',\n          'JNI_CreateJavaVM',\n          '_JNIEnv.*',\n          'JNI_GetCreatedJavaVM.*',\n          'js::AutoCompartment::AutoCompartment.*',\n          'JSAutoCompartment::JSAutoCompartment.*',\n          'JS_DHashTableEnumerate',\n          'JS_DHashTableOperate',\n          'JS_NewStringCopyZ.*',\n          'kill',\n          '__libc_android_abort',\n          'libobjc.A.dylib@0x1568.',\n          '(libxul\\.so|xul\\.dll|XUL)@0x.*',\n          'LL_.*',\n          'malloc',\n          '_MD_.*',\n          'memcmp',\n          '__memcmp16',\n          'memcpy',\n          'memmove',\n          'memset',\n          'mozalloc_abort.*',\n          'mozalloc_handle_oom',\n          'moz_free',\n          'mozilla::AndroidBridge::AutoLocalJNIFrame::~AutoLocalJNIFrame',\n          'mozilla::ipc::RPCChannel::Call',\n          'mozilla::ipc::RPCChannel::CxxStackFrame::CxxStackFrame',\n          'mozilla::ipc::RPCChannel::EnteredCxxStack',\n          'mozilla::ipc::RPCChannel::Send',\n          'mozilla::layers::CompositorD3D11::Failed',\n          'mozilla::layers::CompositorD3D11::HandleError',\n          'mozilla.*FatalError',\n          'moz_xmalloc',\n          'moz_xrealloc',\n          'NP_Shutdown',\n          'nsACString_internal::Assign.*',\n          'nsAString_internal::Assign.*',\n          'nsCOMPtr.*',\n          'NS_ABORT_OOM.*',\n          'NS_DebugBreak.*',\n          '[-+]\\[NSException raise(:format:(arguments:)?)?\\]',\n          'nsObjCExceptionLogAbort(\\(.*?\\)){0,1}',\n          'nsRefPtr.*',\n          'NSS.*',\n          'nss.*',\n          'nsTArray<.*',\n          'nsTArray_base<.*',\n          'NtUser.*',\n          'objc_exception_throw',\n          'objc_msgSend',\n          'operator new\\([^,\\)]+\\)',\n          'PL_.*',\n          'port_.*',\n          'PORT_.*',\n          '_PR_.*',\n          'PR_.*',\n          '.*ProcessNextEvent.*',\n          'pthread_mutex_lock',\n          '_purecall',\n          'raise',\n          'realloc',\n          'recv',\n          '.*ReentrantMonitor::Wait.*',\n          '_RTC_Terminate',\n          'Rtl.*',\n          '_Rtl.*',\n          '__Rtl.*',\n          'SEC_.*Item',\n          'seckey_.*',\n          'SECKEY_.*',\n          '__security_check_cookie',\n          'send',\n          'setjmp',\n          'sigblock',\n          'sigprocmask',\n          'SocketAccept',\n          'SocketAcceptRead',\n          'SocketAvailable',\n          'SocketAvailable64',\n          'SocketBind',\n          'SocketClose',\n          'SocketConnect',\n          'SocketGetName',\n          'SocketGetPeerName',\n          'SocketListen',\n          'SocketPoll',\n          'SocketRead',\n          'SocketRecv',\n          'SocketSend',\n          'SocketShutdown',\n          'SocketSync',\n          'SocketTransmitFile',\n          'SocketWrite',\n          'SocketWritev',\n          'ssl_.*',\n          'SSL_.*',\n          'strcat',\n          'ssl3_.*',\n          'strchr',\n          'strcmp',\n          'strcpy',\n          '.*strdup',\n          'strlen',\n          'strncpy',\n          'strzcmp16',\n          'strstr',\n          '__swrite',\n          'TlsGetValue',\n          'TouchBadMemory',\n          '_VEC_memcpy',\n          '_VEC_memzero',\n          '.*WaitFor.*',\n          'wcslen',\n          '__wrap_realloc',\n          'WSARecv.*',\n          'WSASend.*',\n          '_ZdaPvRKSt9nothrow_t\\\"',\n          'zzz_AsmCodeRange_.*',\n          '.*DebugAbort.*',\n          'mozilla::ipc::MessageChannel::~MessageChannel.*',\n        ])\"\"\",\n        from_string_converter=eval\n    )\n    required_config.add_option(\n        'signatures_with_line_numbers_re',\n        doc=(\n            'any signatures that match this list should be combined '\n            'with their associated source code line numbers'\n        ),\n        default='js_Interpret'\n    )\n\n    #--------------------------------------------------------------------------\n    def __init__(self, config, quit_check_callback=None):\n        super(CSignatureTool, self).__init__(config, quit_check_callback)\n        self.irrelevant_signature_re = re.compile(\n            self.config.irrelevant_signature_re\n        )\n        self.prefix_signature_re = re.compile(\n            self.config.prefix_signature_re\n        )\n        self.signatures_with_line_numbers_re = re.compile(\n            self.config.signatures_with_line_numbers_re\n        )\n        self.signature_sentinels = config.signature_sentinels\n\n\n#==============================================================================\nclass CSignatureToolDB(CSignatureToolBase):\n    \"\"\"This is another C/C++ signature generation class.  It gets its signature\n    generation rules from a database connection instead of through\n    configuration.  It expects a table to exist in the database called\n    'csignature_rules' with two columns, 'category' and 'rule', both of a\n    character datatype.  Content of the 'rule' column is a text string\n    that can be converted via the Python 'eval' method into a Python object.\n    For most categories, the rule is simply a string that is converted into\n    a regular expression.  For the 'sentinel' category, however, the form\n    can be either a string or a tuple comprised of a string and a reference\n    to a Python function, usually in the form of a lambda expression.\"\"\"\n    required_config = Namespace()\n    required_config.add_option(\n        'database_class',\n        doc=\"the class of the database\",\n        default='socorro.external.postgresql.connection_context.'\n                'ConnectionContext',\n        from_string_converter=class_converter\n    )\n    required_config.add_option(\n        'transaction_executor_class',\n        default=\"socorro.database.transaction_executor.\"\n                \"TransactionExecutorWithInfiniteBackoff\",\n        doc='a class that will manage transactions',\n        from_string_converter=class_converter\n    )\n\n    #--------------------------------------------------------------------------\n    def __init__(self, config, quit_check_callback=None):\n        super(CSignatureToolDB, self).__init__(config, quit_check_callback)\n        self.database = config.database_class(config)\n        self.transaction = \\\n            self.config.transaction_executor_class(\n                config,\n                self.database,\n                quit_check_callback\n            )\n        self.transaction(self._read_signature_rules_from_database)\n\n    #--------------------------------------------------------------------------\n    def _read_signature_rules_from_database(self, connection):\n        for category, category_re in (\n            ('prefix', 'prefix_signature_re'),\n            ('irrelevant', 'irrelevant_signature_re'),\n            ('line_number', 'signatures_with_line_numbers_re')\n        ):\n            rule_element_list = [\n                a_rule\n                for (a_rule,) in execute_query_fetchall(\n                    connection,\n                    \"select rule from skiplist \"\n                    \"where category = %s\",\n                    (category, )\n                )\n            ]\n            setattr(\n                self,\n                category_re,\n                re.compile('|'.join(rule_element_list))\n            )\n\n        # get sentinel rules\n        self.signature_sentinels = [\n            eval(sentinel_rule)  # eval quoted strings and tuples\n            if sentinel_rule[0] in \"'\\\"(\" else\n            sentinel_rule  # already a string, don't need to eval\n            for (sentinel_rule,) in execute_query_fetchall(\n                connection,\n                \"select rule from csignature_rules where category = 'sentinel'\"\n            )\n        ]\n\n\n#==============================================================================\nclass JavaSignatureTool(SignatureTool):\n    \"\"\"This is the signature generation class for Java signatures.\"\"\"\n\n    java_line_number_killer = re.compile(r'\\.java\\:\\d+\\)$')\n    java_hex_addr_killer = re.compile(r'@[0-9a-f]{8}')\n\n    #--------------------------------------------------------------------------\n    @staticmethod\n    def join_ignore_empty(delimiter, list_of_strings):\n        return delimiter.join(x for x in list_of_strings if x)\n\n    #--------------------------------------------------------------------------\n    def _do_generate(self,\n                     source,\n                     hang_type_unused=0,\n                     crashed_thread_unused=None,\n                     delimiter=': '):\n        signature_notes = []\n        try:\n            source_list = [x.strip() for x in source.splitlines()]\n        except AttributeError:\n            signature_notes.append(\n                'JavaSignatureTool: stack trace not in expected format'\n            )\n            return (\n                \"EMPTY: Java stack trace not in expected format\",\n                signature_notes\n            )\n        try:\n            java_exception_class, description = source_list[0].split(':', 1)\n            java_exception_class = java_exception_class.strip()\n            # relace all hex addresses in the description by the string <addr>\n            description = self.java_hex_addr_killer.sub(\n                r'@<addr>',\n                description\n            ).strip()\n        except ValueError:\n            java_exception_class = source_list[0]\n            description = ''\n            signature_notes.append(\n                'JavaSignatureTool: stack trace line 1 is '\n                'not in the expected format'\n            )\n        try:\n            java_method = re.sub(\n                self.java_line_number_killer,\n                '.java)',\n                source_list[1]\n            )\n            if not java_method:\n                signature_notes.append(\n                    'JavaSignatureTool: stack trace line 2 is empty'\n                )\n        except IndexError:\n            signature_notes.append(\n                'JavaSignatureTool: stack trace line 2 is missing'\n            )\n            java_method = ''\n\n        # an error in an earlier version of this code resulted in the colon\n        # being left out of the division between the description and the\n        # java_method if the description didn't end with \"<addr>\".  This code\n        # perpetuates that error while correcting the \"<addr>\" placement\n        # when it is not at the end of the description.  See Bug 865142 for\n        # a discussion of the issues.\n        if description.endswith('<addr>'):\n            # at which time the colon placement error is to be corrected\n            # just use the following line as the replacement for this entire\n            # if/else block\n            signature = self.join_ignore_empty(\n                delimiter,\n                (java_exception_class, description, java_method)\n            )\n        else:\n            description_java_method_phrase = self.join_ignore_empty(\n                ' ',\n                (description, java_method)\n            )\n            signature = self.join_ignore_empty(\n                delimiter,\n                (java_exception_class, description_java_method_phrase)\n            )\n\n        if len(signature) > self.max_len:\n            signature = delimiter.join(\n                (java_exception_class, java_method)\n            )\n            signature_notes.append(\n                'JavaSignatureTool: dropped Java exception '\n                'description due to length'\n            )\n\n        return signature, signature_notes\n\n\n#==============================================================================\nclass SignatureGenerationRule(Rule):\n    required_config = Namespace()\n    required_config.namespace('c_signature')\n    required_config.c_signature.add_option(\n        'c_signature_tool_class',\n        doc='the class that can generate a C signature',\n        default='socorro.processor.signature_utilities.CSignatureTool',\n        from_string_converter=class_converter\n    )\n    required_config.c_signature.add_option(\n        'maximum_frames_to_consider',\n        doc='the maximum number of frames to consider',\n        default=40,\n    )\n    required_config.namespace('java_signature')\n    required_config.java_signature.add_option(\n        'java_signature_tool_class',\n        doc='the class that can generate a Java signature',\n        default='socorro.processor.signature_utilities.JavaSignatureTool',\n        from_string_converter=class_converter\n    )\n\n    #--------------------------------------------------------------------------\n    def __init__(self, config):\n        super(SignatureGenerationRule, self).__init__(config)\n        self.java_signature_tool = (\n            self.config.java_signature.java_signature_tool_class(\n                config.java_signature\n            )\n        )\n        self.c_signature_tool = self.config.c_signature.c_signature_tool_class(\n            config.c_signature\n        )\n\n    #--------------------------------------------------------------------------\n    def _create_frame_list(\n        self,\n        crashing_thread_mapping,\n        make_modules_lower_case=False\n    ):\n        frame_signatures_list = []\n        for a_frame in islice(\n            crashing_thread_mapping.get('frames', {}),\n            self.config.c_signature.maximum_frames_to_consider\n        ):\n            if make_modules_lower_case and 'module' in a_frame:\n                a_frame['module'] = a_frame['module'].lower()\n\n            normalized_signature = self.c_signature_tool.normalize_signature(\n                **a_frame\n            )\n            if 'normalized' not in a_frame:\n                a_frame['normalized'] = normalized_signature\n            frame_signatures_list.append(normalized_signature)\n        return frame_signatures_list\n\n    #--------------------------------------------------------------------------\n    def _get_crashing_thread(self, processed_crash):\n        return processed_crash.json_dump['crash_info']['crashing_thread']\n\n    #--------------------------------------------------------------------------\n    def _action(self, raw_crash, raw_dumps, processed_crash, processor_meta):\n        if 'JavaStackTrace' in raw_crash and raw_crash.JavaStackTrace:\n            # generate a Java signature\n            signature, signature_notes = self.java_signature_tool.generate(\n                raw_crash.JavaStackTrace,\n                delimiter=': '\n            )\n            processed_crash.signature = signature\n            if signature_notes:\n                processor_meta.processor_notes.extend(signature_notes)\n            return True\n\n        try:\n            crashed_thread = self._get_crashing_thread(processed_crash)\n        except KeyError:\n            crashed_thread = None\n        try:\n            if processed_crash.get('hang_type', None) == 1:\n                # force the signature to come from thread 0\n                signature_list = self._create_frame_list(\n                    processed_crash.json_dump[\"threads\"][0],\n                    processed_crash.json_dump['system_info']['os'] in\n                    \"Windows NT\"\n                )\n            elif crashed_thread is not None:\n                signature_list = self._create_frame_list(\n                    processed_crash.json_dump[\"threads\"][crashed_thread],\n                    processed_crash.json_dump['system_info']['os'] in\n                    \"Windows NT\"\n                )\n            else:\n                signature_list = []\n        except Exception, x:\n            processor_meta.processor_notes.append(\n                'No crashing frames found because of %s' % x\n            )\n            signature_list = []\n\n        signature, signature_notes = self.c_signature_tool.generate(\n            signature_list,\n            processed_crash.get('hang_type', ''),\n            crashed_thread,\n        )\n        processed_crash.signature = signature\n        if signature_notes:\n            processor_meta.processor_notes.extend(signature_notes)\n        return True\n\n\n#==============================================================================\nclass OOMSignature(Rule):\n    \"\"\"To satisfy Bug 1007530, this rule will modify the signature to\n    tag OOM (out of memory) crashes\"\"\"\n\n    signature_fragments = (\n        'NS_ABORT_OOM',\n        'mozalloc_handle_oom',\n        'CrashAtUnhandlableOOM'\n    )\n\n    #--------------------------------------------------------------------------\n    def version(self):\n        return '1.0'\n\n    #--------------------------------------------------------------------------\n    def _predicate(self, raw_crash, raw_dumps, processed_crash, proc_meta):\n        if 'OOMAllocationSize' in raw_crash:\n            return True\n        signature = processed_crash.signature\n        for a_signature_fragment in self.signature_fragments:\n            if a_signature_fragment in signature:\n                return True\n        return False\n\n    #--------------------------------------------------------------------------\n    def _action(self, raw_crash, raw_dumps, processed_crash, processor_meta):\n        processed_crash.original_signature = processed_crash.signature\n        try:\n            size = int(raw_crash.OOMAllocationSize)\n        except (TypeError, AttributeError, KeyError):\n            processed_crash.signature = (\n                \"OOM | unknown | \" + processed_crash.signature\n            )\n            return True\n\n        if size <= 262144:  # 256K\n            processed_crash.signature = \"OOM | small\"\n        else:\n            processed_crash.signature = (\n                \"OOM | large | \" + processed_crash.signature\n            )\n        return True\n\n\n#==============================================================================\nclass SigTrunc(Rule):\n    \"\"\"ensure that the signature is never longer than 255 characters\"\"\"\n\n    #--------------------------------------------------------------------------\n    def version(self):\n        return '1.0'\n\n    #--------------------------------------------------------------------------\n    def _predicate(self, raw_crash, raw_dumps, processed_crash, proc_meta):\n        return len(processed_crash.signature) > 255\n\n    #--------------------------------------------------------------------------\n    def _action(self, raw_crash, raw_dumps, processed_crash, processor_meta):\n        processed_crash.signature = \"%s...\" % processed_crash.signature[:252]\n        return True\n\n\n#==============================================================================\nclass StackwalkerErrorSignatureRule(Rule):\n    \"\"\"ensure that the signature contains the stackwalker error message\"\"\"\n\n    #--------------------------------------------------------------------------\n    def version(self):\n        return '1.0'\n\n    #--------------------------------------------------------------------------\n    def _predicate(self, raw_crash, raw_dumps, processed_crash, proc_meta):\n        return processed_crash.signature.startswith('EMPTY')\n\n    #--------------------------------------------------------------------------\n    def _action(self, raw_crash, raw_dumps, processed_crash, processor_meta):\n        processed_crash.signature = \"%s; %s\" % (\n            processed_crash.signature,\n            processed_crash.mdsw_status_string\n        )\n        return True\n\n\n#==============================================================================\nclass SignatureRunWatchDog(SignatureGenerationRule):\n    \"\"\"ensure that the signature contains the stackwalker error message\"\"\"\n\n    #--------------------------------------------------------------------------\n    def version(self):\n        return '1.0'\n\n    #--------------------------------------------------------------------------\n    def _predicate(self, raw_crash, raw_dumps, processed_crash, proc_meta):\n        return '::RunWatchdog(void*)' in processed_crash['signature']\n\n    #--------------------------------------------------------------------------\n    def _get_crashing_thread(self, processed_crash):\n        return 0\n\n    #--------------------------------------------------------------------------\n    def _action(self, raw_crash, raw_dumps, processed_crash, processor_meta):\n        result = super(SignatureRunWatchDog, self)._action(\n            raw_crash,\n            raw_dumps,\n            processed_crash,\n            processor_meta\n        )\n        processed_crash['signature'] = (\n            \"shutdownhang | %s\" % processed_crash['signature']\n        )\n        return result\n","markers":{"markers":{"1":{"id":1,"range":[[291,29],[291,29]],"tailed":false,"reversed":false,"valid":true,"invalidate":"never","persistent":true,"properties":{"type":"selection","editorId":10,"goalScreenRange":null},"deserializer":"Marker"},"7":{"id":7,"range":[[291,10],[291,27]],"tailed":true,"reversed":false,"valid":true,"invalidate":"overlap","persistent":true,"properties":{},"deserializer":"Marker"}},"deserializer":"MarkerManager"},"history":{"undoStack":[{"patches":[{"oldRange":[[290,20],[290,20]],"newRange":[[290,20],[291,0]],"oldText":"","newText":"\n","normalizeLineEndings":true,"deserializer":"BufferPatch"},{"oldRange":[[291,0],[291,0]],"newRange":[[291,0],[291,10]],"oldText":"","newText":"          ","normalizeLineEndings":true,"oldMarkersSnapshot":{"2":{"range":[[291,0],[291,0]],"valid":true}},"deserializer":"BufferPatch"}],"oldMarkersSnapshot":{"1":{"range":[[290,20],[290,20]],"valid":true}},"deserializer":"Transaction"},{"patches":[{"oldRange":[[291,10],[291,10]],"newRange":[[291,10],[291,12]],"oldText":"","newText":"''","normalizeLineEndings":true,"oldMarkersSnapshot":{"4":{"range":[[291,0],[291,10]],"valid":true},"5":{"range":[[291,0],[292,0]],"valid":true}},"deserializer":"BufferPatch"},{"id":1,"oldParams":{"range":[[291,12],[291,12]]},"newParams":{"range":[[291,11],[291,11]]},"deserializer":"MarkerPatch"},{"oldRange":[[291,11],[291,11]],"newRange":[[291,11],[291,27]],"oldText":"","newText":"CleanupPerAppKey","normalizeLineEndings":true,"oldMarkersSnapshot":{"5":{"range":[[291,0],[292,0]],"valid":true},"6":{"range":[[291,0],[291,12]],"valid":true},"7":{"range":[[291,10],[291,11]],"valid":true}},"deserializer":"BufferPatch"}],"oldMarkersSnapshot":{"1":{"range":[[291,10],[291,10]],"valid":true},"4":{"range":[[291,0],[291,10]],"valid":true},"5":{"range":[[291,0],[292,0]],"valid":true}},"deserializer":"Transaction"},{"patches":[{"oldRange":[[291,28],[291,28]],"newRange":[[291,28],[291,29]],"oldText":"","newText":",","normalizeLineEndings":true,"oldMarkersSnapshot":{"9":{"range":[[291,0],[291,28]],"valid":true},"10":{"range":[[291,0],[292,0]],"valid":true}},"deserializer":"BufferPatch"}],"oldMarkersSnapshot":{"1":{"range":[[291,28],[291,28]],"valid":true},"7":{"range":[[291,10],[291,27]],"valid":true},"9":{"range":[[291,0],[291,28]],"valid":true},"10":{"range":[[291,0],[292,0]],"valid":true}},"deserializer":"Transaction"}],"redoStack":[],"deserializer":"History","version":1},"encoding":"utf8","filePath":"/Users/lonnen/repos/socorro/socorro/processor/signature_utilities.py","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"408fbe63be167f589f51ea2f9f76cc1c4b19587a","deserializer":"TextBuffer"}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":10,"softTabs":true,"displayBuffer":{"id":11,"softWrapped":true,"editorWidthInChars":null,"scrollTop":5236,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/lonnen/repos/socorro/socorro/processor/signature_utilities.py","invisibles":null,"deserializer":"TokenizedBuffer"},"invisibles":null,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/lonnen/repos/socorro/socorro/processor/signature_utilities.py","focused":false,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-python","language-hyperlink","language-todo"],"deserializer":"Workspace"},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"packageStates":{"command-logger":{"eventLog":{"find-and-replace:show":{"count":217,"name":"find-and-replace:show","lastRun":1430935317448},"tree-view:move":{"count":1,"name":"tree-view:move","lastRun":1401898113640},"core:close":{"count":200,"name":"core:close","lastRun":1427929243904},"application:new-file":{"count":7,"name":"application:new-file","lastRun":1423551371279},"core:backspace":{"count":1464,"name":"core:backspace","lastRun":1430935100622},"core:save":{"count":317,"name":"core:save","lastRun":1430935161717},"editor:newline":{"count":177,"name":"editor:newline","lastRun":1430935158975},"core:paste":{"count":110,"name":"core:paste","lastRun":1430935160076},"core:move-down":{"count":1198,"name":"core:move-down","lastRun":1430935158515},"core:move-up":{"count":779,"name":"core:move-up","lastRun":1430935153154},"core:confirm":{"count":678,"name":"core:confirm","lastRun":1430935123537},"editor:move-to-first-character-of-line":{"count":92,"name":"editor:move-to-first-character-of-line","lastRun":1423611337004},"core:move-right":{"count":334,"name":"core:move-right","lastRun":1430935160915},"core:select-left":{"count":6,"name":"core:select-left","lastRun":1413947436381},"editor:select-to-first-character-of-line":{"count":14,"name":"editor:select-to-first-character-of-line","lastRun":1423611759413},"core:cut":{"count":33,"name":"core:cut","lastRun":1423611760848},"editor:indent":{"count":72,"name":"editor:indent","lastRun":1423611764635},"editor:move-to-end-of-screen-line":{"count":81,"name":"editor:move-to-end-of-screen-line","lastRun":1423552066580},"core:move-left":{"count":305,"name":"core:move-left","lastRun":1423611777101},"core:select-up":{"count":82,"name":"core:select-up","lastRun":1423611338572},"fuzzy-finder:toggle-file-finder":{"count":100,"name":"fuzzy-finder:toggle-file-finder","lastRun":1430935108520},"core:undo":{"count":611,"name":"core:undo","lastRun":1423611732423},"project-find:show":{"count":137,"name":"project-find:show","lastRun":1427927707641},"settings-view:install-packages":{"count":3,"name":"settings-view:install-packages","lastRun":1414683711434},"core:select-down":{"count":442,"name":"core:select-down","lastRun":1423551869407},"core:redo":{"count":63,"name":"core:redo","lastRun":1423611751832},"core:cancel":{"count":40,"name":"core:cancel","lastRun":1430935133238},"editor:select-line":{"count":2,"name":"editor:select-line","lastRun":1413954055533},"find-and-replace:focus-next":{"count":26,"name":"find-and-replace:focus-next","lastRun":1414072340776},"find-and-replace:focus-previous":{"count":8,"name":"find-and-replace:focus-previous","lastRun":1414072344015},"core:select-all":{"count":47,"name":"core:select-all","lastRun":1430935114388},"core:delete":{"count":209,"name":"core:delete","lastRun":1423611742849},"pane:show-previous-item":{"count":142,"name":"pane:show-previous-item","lastRun":1423611273041},"pane:show-next-item":{"count":133,"name":"pane:show-next-item","lastRun":1423611271959},"core:move-to-bottom":{"count":4,"name":"core:move-to-bottom","lastRun":1413949804967},"core:move-to-top":{"count":7,"name":"core:move-to-top","lastRun":1423611335591},"pane:reopen-closed-item":{"count":24,"name":"pane:reopen-closed-item","lastRun":1430935109779},"go-to-line:toggle":{"count":7,"name":"go-to-line:toggle","lastRun":1430935117895},"tree-view:remove":{"count":3,"name":"tree-view:remove","lastRun":1412984059744},"application:install-update":{"count":1,"name":"application:install-update","lastRun":1403197342486},"editor:outdent-selected-rows":{"count":27,"name":"editor:outdent-selected-rows","lastRun":1423551400651},"core:copy":{"count":54,"name":"core:copy","lastRun":1423611744148},"editor:indent-selected-rows":{"count":53,"name":"editor:indent-selected-rows","lastRun":1413954466390},"grammar-selector:show":{"count":1,"name":"grammar-selector:show","lastRun":1407352789635},"find-and-replace:show-previous":{"count":47,"name":"find-and-replace:show-previous","lastRun":1413978503431},"editor:select-to-end-of-line":{"count":5,"name":"editor:select-to-end-of-line","lastRun":1423551450475},"command-palette:toggle":{"count":8,"name":"command-palette:toggle","lastRun":1430935125611},"editor:delete-to-beginning-of-line":{"count":2,"name":"editor:delete-to-beginning-of-line","lastRun":1414686933950},"core:select-right":{"count":11,"name":"core:select-right","lastRun":1413951448063},"whitespace:convert-tabs-to-spaces":{"count":1,"name":"whitespace:convert-tabs-to-spaces","lastRun":1413942910210},"color-picker:open":{"count":1,"name":"color-picker:open","lastRun":1413952588454},"editor:display-updated":{"count":2595,"name":"editor:display-updated","lastRun":1431013995330},"pane:item-added":{"count":7,"name":"pane:item-added","lastRun":1430935105044},"pane-container:active-pane-item-changed":{"count":23,"name":"pane-container:active-pane-item-changed","lastRun":1430935105048},"editor:attached":{"count":6,"name":"editor:attached","lastRun":1430935105134},"pane:active-item-changed":{"count":22,"name":"pane:active-item-changed","lastRun":1430935105323},"cursor:moved":{"count":1139,"name":"cursor:moved","lastRun":1430935161150},"selection:changed":{"count":1144,"name":"selection:changed","lastRun":1430935161150},"pane:active-item-modified-status-changed":{"count":13,"name":"pane:active-item-modified-status-changed","lastRun":1430935161708},"snippets:next-tab-stop":{"count":12,"name":"snippets:next-tab-stop","lastRun":1423611764628},"snippets:expand":{"count":12,"name":"snippets:expand","lastRun":1423611764630},"pane:before-item-destroyed":{"count":6,"name":"pane:before-item-destroyed","lastRun":1427929243886},"editor:detached":{"count":11,"name":"editor:detached","lastRun":1427929243903},"editor:will-be-removed":{"count":11,"name":"editor:will-be-removed","lastRun":1427929243904},"pane:item-removed":{"count":6,"name":"pane:item-removed","lastRun":1427929243901},"window:update-available":{"count":1,"name":"window:update-available","lastRun":1427927655132},"window:close":{"count":1,"name":"window:close","lastRun":1427929247004},"editor:consolidate-selections":{"count":3,"name":"editor:consolidate-selections","lastRun":1430935133234}}},"fuzzy-finder":{"/Users/lonnen/repos/socorro/socorro/processor/signature_utilities.py":1430935105323},"keybinding-resolver":{},"metrics":{"sessionLength":93073798},"tree-view":{"directoryExpansionStates":{"/Users/lonnen/repos/socorro":{"isExpanded":true,"entries":{".git":{"isExpanded":false,"entries":{}},".vagrant":{"isExpanded":false,"entries":{}},"akela":{"isExpanded":false,"entries":{}},"alembic":{"isExpanded":false,"entries":{}},"analysis":{"isExpanded":false,"entries":{}},"config":{"isExpanded":false,"entries":{}},"crashes":{"isExpanded":false,"entries":{}},"docs":{"isExpanded":false,"entries":{}},"minidump-stackwalk":{"isExpanded":false,"entries":{}},"pip-cache":{"isExpanded":false,"entries":{}},"puppet":{"isExpanded":false,"entries":{}},"scripts":{"isExpanded":false,"entries":{}},"socorro":{"isExpanded":false,"entries":{}},"socorro-toolbox":{"isExpanded":false,"entries":{}},"socorro-virtualenv":{"isExpanded":false,"entries":{}},"sql":{"isExpanded":false,"entries":{}},"stackwalk":{"isExpanded":false,"entries":{}},"testcrash":{"isExpanded":false,"entries":{}},"tools":{"isExpanded":false,"entries":{}},"webapp-django":{"isExpanded":false,"entries":{}},"wsgi":{"isExpanded":false,"entries":{}}}}},"selectedPath":"/Users/lonnen/repos/socorro/socorro","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200},"find-and-replace":{"viewState":"","modelState":{"useRegex":false,"inCurrentSelection":false,"caseSensitive":false,"wholeWord":false},"projectViewState":"","resultsModelState":{"useRegex":false,"caseSensitive":false},"findHistory":["#mainbody","mainbody","superuser","else","<p>","panel","font-size",".title","middleware","<<<","====","tablesorter","screen.less",".top_changers","tf {","tr {","table.top_changers","endif","notitle","<<<","parser","bugzilla","8","UA-35433268-50","ga('create"],"replaceHistory":["-.html"],"pathsHistory":["-.html"]}}}